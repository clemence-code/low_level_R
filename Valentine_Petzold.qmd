---
title: "Valentine LLR"
author: "Valentine Petzold"
format: html
---

## Types and classes 
### Types
```{r}
typeof(1.5)#double: numerical value
typeof("toto")
typeof('also between single quotes')
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```
types defined set with associated operations.
double roughly real numbers.
everything id a double if you don't tell R integer.
logical for testing.
### Classes
```{r}
iris
typeof(iris)
class(iris)
class(1)#we don't really care just concept to have in mind
```
## Vectors
### Introduction
Many things in R are vectors (and most of the other things are lists).
Vector: a collection of values of the same type.

```{r}
x<-15.25
length(x)# all vectors have a length
x[1] # access to elements
```
```{r}
length(length(x))
typeof(length(x))

```
```{r}
y<-c(1,-2,45,1.5,-1e-10)
y
typeof(y)
y[2]
length(y)
```
```{r}
c(x,y) #combine vectors
```

The 'c' function can be seen as a creation function or, more accurately, as a vector concatenantion function.*

### Character vectors

This is not R strength...

```{r}
z<- "Alice"
length(z)
```
In R everything is a vector so here only 1 not 5.
pearl language

Salvation comes from the 'stringr' package.

```{r}
library(stringr)
```

```{r}
str_length(z)
```
```{r}
complicated<-"ðŸ’•ðŸ˜ðŸ˜‰ðŸ˜‰ðŸ˜†"
complicated
length(complicated)
str_length(complicated)
```

```{r}
#some_values<-c("")
#some_values
#length(some_values)
#str_length(some_values)
```

### Indexing

```{r}
x<-c(6,5,1,2,3,4)
x[3]
```
```{r}
x[4]<-15#change the forth element
x
```
Assignment can be understood has a value semantic assignment: 'x' and 'y' are different vectors with the same initial content.
```{r}
y<-x
y
```
Therefore, modifying 'x' has no effect on 'y'.
```{r}
x[1]<-18
x
y
```
Indexing is made with vectors of any length.
```{r}
x
x[c(2,2,1,4,3)]
```
```{r}
x[0]#only one that does not work bc negative numbers work as well, no possible meaning -> empty numeric vector
x[7]
x[10]#too large gives NA, no value there -> not available
```
```{r}
typeof(numeric(0))
length(numeric)
```
```{r}
typeof(NA)
length(NA)
```
```{r}
typeof(NA_integer_)
NA_integer_
```
```{r}
x
x[c(4, 1, 0, 15)]
```
```{r}
c(numeric(0), 5, numeric(0))
```
```{r}
x
x[c(-1,-4,-12)]#remove
```
```{r}
x
x[c(1,4)]<-c(-34,42)
x
x[c(2,10)]<-c(123,78)
x
```

```{r}
y<-c("A","B","C")
y
y[c(TRUE, FALSE, TRUE)]
```
## Lists

Vectors must be type uniform, which will trigger a conversion to character in many cases.

```{r}
broken<-c(1L, 1.5,"toto",FALSE)
broken
typeof(broken)
```
Lists do not have this limitation.

### Creating a list

```{r}
bar <- list(1L,1.5, "toto", FALSE) #use list instead of c
bar
```
```{r}
typeof(bar)
length(bar)
```
A list can be understood as vector of "vectors". Functions are not a vector.

```{r}
foo <- list(c(1,2,3), TRUE, length)
foo
length(foo)
```
### Indexing
```{r}
foo
foo[1]
cat("###\n")
foo[-2]
cat("###\n")
foo[c(3,2,2,1)]
```

Lists, they behave like vectors if you use the single brackets. 
```{r}
foo[0]
foo[4]
```
NULL missing object not NA missing value. 

### Side step: weird values

```{r}
NA#missing value
NULL#missing object
NaN#not a number
```
NULL not shown as a vector.

```{r}
0/0
1/0
-1/0
1/0-1/0
1/0+1
1/0-10e10
1/Inf
```
```{r}
NA_real_+1
1/NA_real_
```
```{r}
NULL+1
```
### Back to indexing*
```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x
```
```{r}
x[c(1,4,5)]
```
```{r}
x[5]<-c(-2,1)
x
```

```{r}
x[5]<-list(c(-2,1))
x
```

```{r}
y<-c(1,2,3)
y
y[4]<-"toto"
y
```
```{r}
class(x)
#class(x(1))#reduce your list to its first element
```

The indexing operation '[]' does not change the type or the class of the corresponding object.

### Double brackets

```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x[1] 
x[[1]]
```

```{r}
x[2] <-"toto"
x
```

```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x[[2]]<-c("tot","bar")
x[[4]]<-1:15#sequence of integers from 1 to 15
x
```

```{r}
x[[c(1,2)]]
x[[c(3,2)]]#second element of the third cat of the list

```
```{r}
y<-list(1:4,list(letters[1:5],list(c("foo","bar"))))
y
y[[2]]
y[[c(2,1)]]#double bracket extract things
y[[c(2,2,1,2)]] #build trees very imp in computer science the double brackets go in the element
```
### Names

```{r}
z<-list(keys=c("A","B","C"), values=c(10,11,12), key=c(TRUE,FALSE))
z
z[[1]]
z$keys#named access with the dollar operator is similar to the double bracket
z$val#automatik name completion, funny but dangerous, incorrect optimisation
z$key
z$ke
z[["keys"]]
z[["val"]]#exact matching only
z["values"]
z["values"]|> class()
z[["values"]]|> class()

```

Important remark: a data frame is a list in which each element (each colomn) has the same length.

```{r}
names(z)
```

```{r}
names(z)<-c("A","B","C")
z
```

