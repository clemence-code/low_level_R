---
title: "Valentine LLR"
author: "Valentine Petzold"
format: html
---

## Types and classes 
### Types
```{r}
typeof(1.5)#double: numerical value
typeof("toto")
typeof('also between single quotes')
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```
types defined set with associated operations.
double roughly real numbers.
everything id a double if you don't tell R integer.
logical for testing.
### Classes
```{r}
iris
typeof(iris)
class(iris)
class(1)#we don't really care just concept to have in mind
```
## Vectors
### Introduction
Many things in R are vectors (and most of the other things are lists).
Vector: a collection of values of the same type.

```{r}
x<-15.25
length(x)# all vectors have a length
x[1] # access to elements
```
```{r}
length(length(x))
typeof(length(x))

```
```{r}
y<-c(1,-2,45,1.5,-1e-10)
y
typeof(y)
y[2]
length(y)
```
```{r}
c(x,y) #combine vectors
```

The 'c' function can be seen as a creation function or, more accurately, as a vector concatenantion function.*

### Character vectors

This is not R strength...

```{r}
z<- "Alice"
length(z)
```
In R everything is a vector so here only 1 not 5.
pearl language

Salvation comes from the 'stringr' package.

```{r}
library(stringr)
```

```{r}
str_length(z)
```
```{r}
complicated<-"ðŸ’•ðŸ˜ðŸ˜‰ðŸ˜‰ðŸ˜†"
complicated
length(complicated)
str_length(complicated)
```

```{r}
#some_values<-c("")
#some_values
#length(some_values)
#str_length(some_values)
```

### Indexing

```{r}
x<-c(6,5,1,2,3,4)
x[3]
```
```{r}
x[4]<-15#change the forth element
x
```
Assignment can be understood has a value semantic assignment: 'x' and 'y' are different vectors with the same initial content.
```{r}
y<-x
y
```
Therefore, modifying 'x' has no effect on 'y'.
```{r}
x[1]<-18
x
y
```
Indexing is made with vectors of any length.
```{r}
x
x[c(2,2,1,4,3)]
```
```{r}
x[0]#only one that does not work bc negative numbers work as well, no possible meaning -> empty numeric vector
x[7]
x[10]#too large gives NA, no value there -> not available
```
```{r}
typeof(numeric(0))
length(numeric)
```
```{r}
typeof(NA)
length(NA)
```
```{r}
typeof(NA_integer_)
NA_integer_
```
```{r}
x
x[c(4, 1, 0, 15)]
```
```{r}
c(numeric(0), 5, numeric(0))
```
```{r}
x
x[c(-1,-4,-12)]#remove
```
```{r}
x
x[c(1,4)]<-c(-34,42)
x
x[c(2,10)]<-c(123,78)
x
```

```{r}
y<-c("A","B","C")
y
y[c(TRUE, FALSE, TRUE)]
```
## Lists

Vectors must be type uniform, which will trigger a conversion to character in many cases.

```{r}
broken<-c(1L, 1.5,"toto",FALSE)
broken
typeof(broken)
```
Lists do not have this limitation.

### Creating a list

```{r}
bar <- list(1L,1.5, "toto", FALSE) #use list instead of c
bar
```
```{r}
typeof(bar)
length(bar)
```
A list can be understood as vector of "vectors". Functions are not a vector.

```{r}
foo <- list(c(1,2,3), TRUE, length)
foo
length(foo)
```
### Indexing
```{r}
foo
foo[1]
cat("###\n")
foo[-2]
cat("###\n")
foo[c(3,2,2,1)]
```

Lists, they behave like vectors if you use the single brackets. 
```{r}
foo[0]
foo[4]
```
NULL missing object not NA missing value. 

### Side step: weird values

```{r}
NA#missing value
NULL#missing object
NaN#not a number
```
NULL not shown as a vector.

```{r}
0/0
1/0
-1/0
1/0-1/0
1/0+1
1/0-10e10
1/Inf
```
```{r}
NA_real_+1
1/NA_real_
```
```{r}
NULL+1
```
### Back to indexing*
```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x
```
```{r}
x[c(1,4,5)]
```
```{r}
x[5]<-c(-2,1)
x
```

```{r}
x[5]<-list(c(-2,1))
x
```

```{r}
y<-c(1,2,3)
y
y[4]<-"toto"
y
```
```{r}
class(x)
#class(x(1))#reduce your list to its first element
```

The indexing operation '[]' does not change the type or the class of the corresponding object.

### Double brackets

```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x[1] 
x[[1]]
```

```{r}
x[2] <-"toto"
x
```

```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x[[2]]<-c("tot","bar")
x[[4]]<-1:15#sequence of integers from 1 to 15
x
```

```{r}
x[[c(1,2)]]
x[[c(3,2)]]#second element of the third cat of the list

```
```{r}
y<-list(1:4,list(letters[1:5],list(c("foo","bar"))))
y
y[[2]]
y[[c(2,1)]]#double bracket extract things
y[[c(2,2,1,2)]] #build trees very imp in computer science the double brackets go in the element
```
### Names

```{r}
z<-list(keys=c("A","B","C"), values=c(10,11,12), key=c(TRUE,FALSE))
z
z[[1]]
z$keys#named access with the dollar operator is similar to the double bracket
z$val#automatik name completion, funny but dangerous, incorrect optimisation
z$key
z$ke
z[["keys"]]
z[["val"]]#exact matching only
z["values"]
z["values"]|> class()
z[["values"]]|> class()

```

Important remark: a data frame is a list in which each element (each colomn) has the same length.

```{r}
names(z)
```

```{r}
names(z)<-c("A","B","C")
z
```

### Functions

Very important. R extensions (packages) consist essentially in collections of functions.

```{r}
names
```

a function is an object that you can call by adding parentheses after the function name and possibly parameters inside the parentheses (effective parameters/formal parameters)

```{r}
log
```
In R, functions can have multiples formal parameters and some of them may have default values. When a function is called, one has to specify in general at least the values ofr the parameters without a default value.

```{r}
log(10)##base takes the default value (e)
log(10,10)## now base=10
```

```{r}
seq.int
```
```{r}
seq.int(1,10)#by is set to 1
seq.int(10,1)#by is set to -1

```

### Creating functions

This is done with the 'function' key word.

```{r}
my_fun<-function(x,y) { ##between parenthesis we specify the formal parameters 
  ##between the curly braces {} we describe the operations implemented by
  ##the function
  2*abs(x-y)/(abs(x)+abs(y)+1e-15)
  
}
```

```{r}
my_fun
functionBody(my_fun)
```


```{r}
my_fun(1,2)
my_fun(2,1)
my_fun(2,2)
my_fun(0,0)
```
Function execution is essentially running the code inside the body the function after replacing the formal parameters by the values used as effective parameters at the call point. The value of the call is the last value computed in the function. 

```{r}
my_fun(4,1)  #x=4 and y=1
```

```{r}
my_second_fun<-function(x,y) {
  z<-x+y
  z/y
  z/x
}
```

```{r}
my_second_fun(1,2)
```
A variable defined in a function is private to the function. It does not care about existing variables with the same name and it dissapears just before the end of the function execution.

```{r}
z<-10
my_second_fun(1,2)
z
```
### Default parameters

To specify a default value for a parameter, we add a equal sign '=' after the formal parameter name followed by the default value.

```{r}
x_to_y<-function(x,y=2) {
  x^y
}
```

```{r}
x_to_y(2,3)
x_to_y(10)
```
Standard calls use positional effective parameters: all effective parameters are specified in the order of the formal parameters. 

This can be combined with named effective parameters: the name pf the format parameter is used in the call, followed by an egal sigb and the chosen value. In this case, order does not matter anymore. 

```{r}
x_to_y(y=4,x=2) #2^4
```

Position and names can be combined if all names are after the unnamed parameters. 

### Functions are objects

R has some features of functional language. 

```{r}
all_my_funs<-list(f1=my_fun, f2=my_second_fun, f3=x_to_y)
all_my_funs
```

You can put anything in a list : data set etc.

```{r}
all_my_funs[["f3"]](10,5.5)
```
\(x) short-cut to create a function

```{r}
x<-list(1:3, letters[10:20])
x
```
'lapply' applies a function to each of the elements of a list and returns a list made with the results. 
```{r}
lapply(x,length)
```
This work also on a vector (not in all cases but in general), the result is still a list. 

```{r}
lapply(1:10, x_to_y)
```
'sapply' tries to simplify the resulting list into a vector (or an array, we'll discuss it later today) if the content of the list has a single type. 

```{r}
sapply(x,length)
sapply(1:10, x_to_y)
```
... a way of extending the call of a function to something much more complex, in other word you can add different parameters. 

Each call to 'x_to_y' has a first effective parameter (arguments) taken in the vector '1:10' and a second named parameter 'y=3'.
```{r}
sapply(1:10, x_to_y, y=3)
```

```{r}
my_data<- list(x=1:10,
               y=c(NA,2:5,NA,6:20))
my_data
```

```{r}
lapply(my_data, mean)
```

In this version, the parameter 'na.rm' is set to 'TRUE' in all the mean calculations.

```{r}
lapply(my_data, mean, na.rm=TRUE)
```

### Anonymous functions aka lambdas

Compact function declaration (can be used directly as parameters).

```{r}
\(x) x^2 #in parentheses the parameter you define
```

```{r}
(\(x) x^2) |>class()
```
```{r}
log(1:10, base=10)
```
A complicated way of ddoing something simple. 

```{r}
sapply(1:10, \(x, y) 1+y*log(x), y=2)
```
```{r}
1+2*log(1:10)
```
```{r}
my_data<- list(x=1:10,
               y=c(NA,2:5,NA,6:20))
my_data
lapply(my_data, mean, na.rn=TRUE)
lapply(my_data, \(x) mean(x,na.rm=TRUE))
```




