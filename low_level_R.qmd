---
title: "low_level_R"
format: html
editor: visual
---

## Types and classes

### Types

```{r}
typeof(1.5)#double: numerical value
typeof("toto")
typeof('also between single quotes')
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```

types defined set with associated operations. double roughly real numbers. everything id a double if you don't tell R integer. logical for testing. \### Classes

```{r}
iris
typeof(iris)
class(iris)
class(1)#we don't really care just concept to have in mind
```

## Vectors

Many things in R are vectors( and most of the other things are lists). A vector is a collection of values of the same type (possibly a single value).

```{r}
x <- 15.25
length(x)
```

The `c` function can be seen as a creation function or, more accurately, as a vector concatenation function.

```{r}
y <- 15.25
c(x,y)
```

### Character vectors

```{r}
z <- "Bob"
length(z)
```

Salvation comes from the `stringr` package.

```{r}
library(stringr)
```

```{r}
str_length(z)
```

```{r}
complicated <-"ðŸ’•ðŸ˜ðŸ˜‰ðŸ˜‰ðŸ˜†Ræ˜¯ä¸€é—¨å¾ˆå¥½çš„ç¼–ç¨‹è¯­è¨€"
length(complicated)
str_length(complicated)
```

```{r}
some_values <- c("ðŸ’•ðŸ˜ðŸ˜‰ðŸ˜‰ðŸ˜†","Ræ˜¯ä¸€é—¨å¾ˆå¥½çš„ç¼–ç¨‹è¯­è¨€")
some_values
length(some_values)
str_length(some_values)
str_to_upper(some_values)
```

### Indexing

```{r}
x <- c(6,5,1,2,3,4)
y <- c(6,5,1,2,3,4)
x[3]
```

```{r}
x[4] <- 15
x
```

Assignment can be understood as a value semantic assignment : `x` and `y` are different vectors with the same initial content.

```{r}
y <- x
```

Therefore, modifying `x` has no effect on `y`.

Indexing is made with vectors of any length.

```{r}
x
x[c(2,2,1,4,3)]
```

```{r}
x[0]
x[7]
x[10]
```

```{r}
typeof(NA_integer_)
NA_integer_
```

```{r}
x
x[c(4,1,0,15)]
```

```{r}
c(numeric(0),5,numeric(0))
```

```{r}
y <- c("A","B","C")
y
y[c(TRUE,FALSE,TRUE)]
```

```{r}
x
x[c(1,4)] <- c(-34,22)
x
x[c(2,10)] <- c(123,456)
x
```


```{r}
y<-c("A","B","C")
y
y[c(TRUE, FALSE, TRUE)]
```
## Lists

Vectors must be type uniform, which will trigger a conversion to character in many cases.

```{r}
broken<-c(1L, 1.5,"toto",FALSE)
broken
typeof(broken)
```
Lists do not have this limitation.

### Creating a list

```{r}
bar <- list(1L,1.5, "toto", FALSE) #use list instead of c
bar
```
```{r}
typeof(bar)
length(bar)
```
A list can be understood as vector of "vectors". Functions are not a vector.

```{r}
foo <- list(c(1,2,3), TRUE, length)
foo
length(foo)
```
### Indexing
```{r}
foo
foo[1]
cat("###\n")
foo[-2]
cat("###\n")
foo[c(3,2,2,1)]
```

Lists, they behave like vectors if you use the single brackets. 
```{r}
foo[0]
foo[4]
```
NULL missing object not NA missing value. 

### Side step: weird values

```{r}
NA#missing value
NULL#missing object
NaN#not a number
```
NULL not shown as a vector.

```{r}
0/0
1/0
-1/0
1/0-1/0
1/0+1
1/0-10e10
1/Inf
```
```{r}
NA_real_+1
1/NA_real_
```
```{r}
NULL+1
```
### Back to indexing*
```{r}
x<-list(c(1,2,3), c(TRUE,FALSE), LETTERS[10:15])
x
```
```{r}
x[c(1,4,5)]
```
```{r}
x[5]<-c(-2,1)
x
```

```{r}
x[5]<-list(c(-2,1))
x
```

```{r}
y<-c(1,2,3)
y
y[4]<-"toto"
y
```


